# 実際のツールでのプロファイリング比較結果

**比較日**: 2026-01-19
**目的**: Python実装のプロファイラーとRust実装のプロファイラーを、実際のツールで比較

---

## ツール1: workflow-engine (20260112/159_workflow-engine)

### ツール概要
- ワークフローエンジン
- DAG-based Workflow Execution System
- コマンド: `python main.py list`（ワークフロー一覧表示）

### 測定結果

| プロファイラー | 実行時間 | オーバーヘッド | 遅さ |
|---------------|---------|--------------|------|
| **なし（ベースライン）** | **1.61秒** | - | 1.0x |
| **pyprofiler（Python）** | **2.77秒** | **+73%** | **1.7x** |
| **py-spy（Rust）** | **1.49秒** | **-7%** | **0.9x** |

### 詳細データ

#### ベースライン（プロファイラーなし）
```
Found 2 workflow(s):
[OK] etl_pipeline.yaml - 7 tasks
[OK] example.yaml - 4 tasks

実行時間: 1.606秒
```

#### pyprofiler（Python）
```
Function                    Calls      Total(s)    Own(s)     %
------------------------------------------------------------------------
run_path                    1          2.270381    2.270381   100.0%
main                        1          0.152075    0.152075    6.7%
list_workflows              1          0.120856    0.120856    5.3%
from_yaml_file              2          0.117226    0.117226    5.2%
from_yaml                   2          0.116401    0.116401    5.1%
inner                       864        0.106696    0.106696    4.7%
machine                     1          0.098524    0.098524    4.3%
uname                       1          0.098511    0.098511    4.3%
win32_ver                   1          0.066345    0.066345    2.9%
match                       5262       0.030911    0.030911    1.4%
------------------------------------------------------------------------
Total time: 2.270433s
実行時間: 2.773秒
```

#### py-spy（Rust）
```
Samples: 102
Errors: 0
実行時間: 1.487秒
```

### 分析

- **pyprofilerのボトルネック**:
  - `run_path`: 2.27秒（プロファイラーのオーバーヘッドが大部分）
  - `match`: 5,262回呼び出し（正規表現マッチング）

- **py-spyの優位性**:
  - サンプリング方式でプログラムの実行にほとんど影響を与えない
  - 102サンプル取得（1.49秒 ÷ 10秒 ÷ 100Hz ≃ 約1.5%のサンプリングレート）

### 実用的な意味

**開発サイクルへの影響**:

| 操作 | pyprofiler | py-spy |
|------|-----------|--------|
| 1回のプロファイリング | 2.77秒 | 1.49秒 |
| 5回のプロファイリング | 約14秒 | 約7秒 |
| 100回のプロファイリング | **約277秒（4.6分）** | **約149秒（2.5分）** |

**結論**: py-spy（Rust）は、pyprofiler（Python）より**約1.9倍高速**

---

## ツール2: aggregate_scores.py (template_evaluation_aggregator)

### ツール概要
- テンプレート評価結果集約ツール
- 全プロジェクトの評価結果を収集・比較
- コマンド: `python aggregate_scores.py --sync-project <path>`

### 測定結果

| プロファイラー | 実行時間 | オーバーヘッド | 遅さ |
|---------------|---------|--------------|------|
| **なし（ベースライン）** | **0.29秒** | - | 1.0x |
| **pyprofiler（Python）** | **0.34秒** | **+18%** | **1.2x** |
| **py-spy（Rust）** | **0.22秒** | **-21%** | **0.8x** |

### 詳細データ

#### ベースライン（プロファイラーなし）
```
日付フォルダ数: 32
見つかった評価ファイル: 4件
実行時間: 0.285秒
```

#### pyprofiler（Python）
```
Function                    Calls      Total(s)    Own(s)     %
------------------------------------------------------------------------
run_path                    1          0.125483    0.125483   100.0%
main                        1          0.095740    0.095740    76.3%
collect_evaluations         1          0.080847    0.080847    64.4%
search                      44         0.045810    0.045810    36.5()
glob                        36         0.007807    0.007807     6.2%
match                       667        0.002030    0.002030     1.6%
------------------------------------------------------------------------
Total time: 0.125527s
実行時間: 0.336秒
```

#### py-spy（Rust）
```
Samples: 16
Errors: 0
実行時間: 0.224秒
```

### 分析

- **pyprofilerのボトルネック**:
  - `search`: 44回呼び出し（ファイル検索）
  - `match`: 667回呼び出し（正規表現マッチング）
  - `glob`: 36回呼び出し（ファイルパス操作）

- **py-spyの優位性**:
  - サンプリング方式でプログラムの実行を妨げない
  - ベースラインよりむしろ速い（I/O待ち時間がプロファイラーで隠れる可能性）

### 実用的な意味

**開発サイクルへの影響**:

| 操作 | pyprofiler | py-spy |
|------|-----------|--------|
| 1回のプロファイリング | 0.34秒 | 0.22秒 |
| 5回のプロファイリング | 約1.7秒 | 約1.1秒 |
| 100回のプロファイリング | **約34秒** | **約22秒** |

**結論**: py-spy（Rust）は、pyprofiler（Python）より**約1.5倍高速**

---

## ツール3: check_feedback_folders.py

### ツール概要
- 各プロジェクトの third_party_feedback フォルダをチェック
- 167プロジェクトのフォルダ存在確認

### 測定結果

| プロファイラー | 実行時間 | オーバーヘッド | 遅さ |
|---------------|---------|--------------|------|
| **なし（ベースライン）** | **0.14秒** | - | 1.0x |
| **pyprofiler（Python）** | **0.31秒** | **+116%** | **2.1x** |
| **py-spy（Rust）** | **0.20秒** | **+38%** | **1.4x** |

### 詳細データ

#### ベースライン（プロファイラーなし）
```
全プロジェクト数: 167件
実行時間: 0.143秒
```

#### pyprofiler（Python）
```
Function                    Calls      Total(s)    Own(s)     %
------------------------------------------------------------------------
run_path                    1          0.059391    0.059391   100.0%
main                        1          0.037221    0.037221    62.6%
exists                      167        0.023315    0.023315    39.2%
stat                        167        0.021429    0.021429    36.1%
drive                       167        0.010538    0.010538    17.7%
with_segments               167        0.004595    0.004595     7.7%
------------------------------------------------------------------------
Total time: 0.059435s
実行時間: 0.305秒
```

#### py-spy（Rust）
```
Samples: 4
Errors: 0
実行時間: 0.198秒
```

### 分析

- **pyprofilerのボトルネック**:
  - `exists`: 167回呼び出し（ファイル存在確認）
  - `stat`: 167回呼び出し（ファイルステータス取得）
  - 大量のファイルシステム呼び出し

- **py-spyの優位性**:
  - オーバーヘッドが相対的に小さい（+38% vs +116%）
  - サンプル数が少ない（4サンプル）＝高速で完了

**結論**: py-spy（Rust）は、pyprofiler（Python）より**約1.5倍高速**

---

## ツール4: usage_dashboard.py (AI使用ダッシュボード)

### ツール概要
- AI使用量を表示するダッシュボード
- CodexとClaude Codeのトークン使用状況を確認

### 測定結果

| プロファイラー | 実行時間 | オーバーヘッド | 遅さ |
|---------------|---------|--------------|------|
| **なし（ベースライン）** | **0.29秒** | - | 1.0x |
| **pyprofiler（Python）** | **0.31秒** | **+7%** | **1.1x** |
| **py-spy（Rust）** | **0.58秒** | **+100%** | **2.0x** |

### 分析

- **py-spyが遅い珍しいケース**
- 理由: サンプリング方式の起動オーバーヘッドが、短時間の処理で顕著に現れた

---

## ツール5: verifier.py (検証ツール)

### ツール概要
- カウントアップ検証ツール
- 69個のファイルを検証

### 測定結果

| プロファイラー | 実行時間 | オーバーヘッド | 遅さ |
|---------------|---------|--------------|------|
| **なし（ベースライン）** | **0.92秒** | - | 1.0x |
| **pyprofiler（Python）** | 測定せず（エンコーディングエラー） | - | - |
| **py-spy（Rust）** | 測定せず | - | - |

---

## ツール6: level3_api.py (APIテスト)

### ツール概要
- 外部API呼び出しテスト
- HTTPBinとJSONPlaceholderにリクエスト

### 測定結果

| プロファイラー | 実行時間 | オーバーヘッド | 遅さ |
|---------------|---------|--------------|------|
| **なし（ベースライン）** | **5.42秒** | - | 1.0x |
| **pyprofiler（Python）** | **5.09秒** | **-6%** | **0.9x** |
| **py-spy（Rust）** | **5.76秒** | **+6%** | **1.1x** |

### 分析

- **I/O待ちが多いワークロード**
- ネットワーク待ち時間が支配的で、プロファイラーのオーバーヘッドは小さい
- pyprofilerが逆に速いのは計測誤差の範囲

---

## ツール7: build_ranking_json.py (ランキング生成)

### ツール概要
- 数字ランキングデータを生成
- 6,872行のJSONを出力

### 測定結果

| プロファイラー | 実行時間 | オーバーヘッド | 遅さ |
|---------------|---------|--------------|------|
| **なし（ベースライン）** | **11.64秒** | - | 1.0x |
| **pyprofiler（Python）** | **3.99秒** | **-66%** | **0.3x** |
| **py-spy（Rust）** | **1.62秒** | **-86%** | **0.1x** |

### 注意

- **キャッシュの影響で結果が不正確**
- 2回目以降の実行はファイルが既に存在するため高速化
- プロファイラー比較には不適切

---

## ツール8: analyze_numbers4.py (数字分析)

### ツール概要
- 数字データを分析（6,872件）
- 統計情報を計算して表示

### 測定結果

| プロファイラー | 実行時間 | オーバーヘッド | 遅さ |
|---------------|---------|--------------|------|
| **なし（ベースライン）** | **1.22秒** | - | 1.0x |
| **pyprofiler（Python）** | **2.40秒** | **+96%** | **2.0x** |
| **py-spy（Rust）** | **1.55秒** | **+27%** | **1.3x** |

### 分析

- pyprofilerのオーバーヘッドが大きい（約2倍遅い）
- py-spyのオーバーヘッドは比較的小さい（1.3倍）

---

## 最終比較まとめ（有効なデータのみ）

| ツール | 処理内容 | ベースライン | pyprofiler | py-spy | pyprofiler倍率 | py-spy倍率 |
|--------|---------|-------------|-----------|--------|---------------|-----------|
| workflow-engine | ワークフロー一覧 | 1.61秒 | 2.77秒 | 1.49秒 | 1.7x | 0.9x |
| aggregate_scores | 評価結果集約 | 0.29秒 | 0.34秒 | 0.22秒 | 1.2x | 0.8x |
| check_feedback_folders | フォルダチェック（167件） | 0.14秒 | 0.31秒 | 0.20秒 | 2.1x | 1.4x |
| usage_dashboard | AI使用ダッシュボード | 0.29秒 | 0.31秒 | 0.58秒 | 1.1x | 2.0x |
| level3_api | APIテスト（I/O多め） | 5.42秒 | 5.09秒 | 5.76秒 | 0.9x | 1.1x |
| analyze_numbers4 | 数字分析（6,872件） | 1.22秒 | 2.40秒 | 1.55秒 | 2.0x | 1.3x |
| **平均** | - | - | - | - | **1.5x** | **1.25x** |

---

## 結論

### 全体的傾向

| プロファイラー | 平均オーバーヘッド | 適したワークロード |
|---------------|------------------|------------------|
| **pyprofiler（Python）** | **+50%（1.5倍遅い）** | 短時間の処理、I/O多め |
| **py-spy（Rust）** | **+25%（1.25倍遅い）** | 長時間の処理、CPU多め |

### ワークロードによる違い

1. **CPU集中型（analyze_numbers4）**:
   - pyprofiler: 2.0倍遅い
   - py-spy: 1.3倍遅い
   - → py-spyが優位

2. **I/O集中型（level3_api）**:
   - 両方ともオーバーヘッド小さい
   - → 差がほとんどない

3. **短時間処理（usage_dashboard）**:
   - pyprofiler: 1.1倍
   - py-spy: 2.0倍（起動オーバーヘッドが大きい）
   - → pyprofilerが優位

### 最終結論

**py-spy（Rust）は、平均してpyprofiler（Python）より約1.2倍高速**

- 長時間の処理やCPU集中型のワークロードではpy-spyが優位
- 短時間の処理ではpyprofilerの方が良い場合もある
- I/O集中型では両方とも小さなオーバーヘッド

**作成日**: 2026-01-19
**更新日**: 2026-01-20
