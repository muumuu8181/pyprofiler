# Pythonプロファイラー - 使い道と活用方法

> **プロジェクト**: #27 Pythonプロファイラー
> **品質レベル**: 65点（実用的）

---

## 🎯 プロファイラーの使い道

プロファイラーは**「コードのどの部分が遅いか」を特定するツール**です。

### できること
- **ボトルネックの特定**: どの関数が実行時間の大半を占めているか
- **最適化箇所の発見**: どこを改善すれば最大の効果が得られるか
- **性能回帰の検出**: 新しいコードが意図せず遅くなっていないか

---

## 💡 実践的な使用シーン

### シーン1: Webアプリのレスポンス時間改善

```
問題: APIレスポンスが遅い（2秒かかる）
  ↓
プロファイラー実行:
  - データベースクエリ: 1.5秒 (75%)
  - データ処理: 0.3秒 (15%)
  - レスポンス構築: 0.2秒 (10%)
  ↓
結論: データベースクエリがボトルネック
対策: インデックス追加、キャッシュ導入、N+1問題解決
```

### シーン2: バッチ処理の高速化

```
問題: データ処理バッチが10分かかる
  ↓
プロファイラー実行:
  - CSVパース: 8分 (80%)
  - データ変換: 1.5分 (15%)
  - ファイル書き込み: 0.5分 (5%)
  ↓
結論: CSVパースがボトルネック
対策: pandasの並行処理、より高速なパーサーラーの利用
```

### シーン3: ルループの最適化

```
問題: ネストしたループが遅い
  ↓
プロファイラー実行:
  - 外部API呼び出し: 95%
  - ロジック処理: 5%
  ↓
結論: 外部API呼び出しがボトルネットル
対策: 並列化、キャッシュ、APIリクエスト削減
```

---

## 📊 実際の出力例

```
Function                    Calls    Total(s)   Own(s)   %
---------------------------------------------------------------
fetch_user_from_db         100      1.523      1.523    75.2%
process_user_data           100      0.300      0.300    14.8%
send_notifications          100      0.150      0.150     7.4%
calculate_analytics            1      0.050      0.050     2.5%
---------------------------------------------------------------
Total time: 2.023s
```

**読み方**:
- **Total(s)**: その関数全体の実行時間
- **Own(s)**: その関数自身の処理時間（子呼び出しを除く）
- **%**: 合計時間に占める割合

---

## 🔧 基本的な使い方

### 方法1: デコレーターを使う

```python
from pyprofiler import CPUProfiler

profiler = CPUProfiler()

@profiler.profile_function
def my_slow_function():
    # ここが遅い原因か？
    result = sum(range(1000000))
    return result

# 関数を実行
my_slow_function()

# 統果を表示
profiler.print_stats()
```

### 方法2: コンテキストマネージャーを使う

```python
from pyprofiler import CPUProfiler

profiler = CPUProfiler()

@profiler.profile_function
def function_a():
    return slow_operation()

@profiler.profile_function
def function_b():
    return fast_operation()

# プロファイリング開始
profiler.start()

# コード実行
for i in range(100):
    function_a()
    function_b()

# プロファイリング終了
profiler.stop()

# 統果を表示
profiler.print_stats()
```

---

## 🎓 学べること

プロファイラーを使うと、以下のことが学べます：

1. **データ構造・アルゴリズムの効率**
   - O(n²) のループがボトルネックになっているか
   - 適切なデータ構造を使っているか

2. **システム設計の問題**
   - N+1クエリ問題
   - 不必要なデータベースアクセス
   - 非効率的なI/O

3. **最適化の効果測定**
   - 最適化前後でどれくらい速くなったか
   - どこを改善すれば最大の効果が得られるか

---

## 💼 実務での活用例

### ケース1: APIパフォーマンス改善

```
_before_: APIレスポンス: 2秒
_after_: APIレスポンス: 0.5秒 (75%改善)

施策:
- データベースクエリの最適化
- キャッシュの導入
- 不要な処理の削除
```

### ケース2: バッチ処理の高速化

```
_before_: データ処理: 1時間
_after_: データ処理: 15分 (75%改善)

施策:
- pandasの並列処理
- 効行処理への変更
- メモリ使用量の最適化
```

### ケース3: ルーループの最適化

```
_before_: ルループ処理: 5分
_after_: ルループ処理: 30秒 (90%改善)

施策:
- 並列化
- キャッシュ導入
- アルゴリズム変更
```

---

## 🚀 あなたのプロジェクトで使うには

### Step 1: ボトルネックを疑う

```
「なんか遅いなあ」と思ったらプロファイラーを実行
```

### Step 2: プロファイラーを実行

```python
from pyprofiler import CPUProfiler

profiler = CPUProfiler()
profiler.start()

# あなたのコード
your_slow_function()

profiler.stop()
profiler.print_stats()
```

### Step 3: 結果を見て対策

```
プロファイラー結果:
  slow_function: 80% of time

対策:
  - アルゴリズムを改善
  - キャッシュを導入
  - 並列化する
```

### Step 4: 改善後もプロファイリング

```
改善後も再度プロファイリングして、
次のボトルネックを見つける
```

---

## 📈 65点（実用レベル）の意味

このプロファイラーは以下のレベルで実用的です：

✅ **できること**
- 関数ごとの実行時間計測
- 呼び出し回数の記録
- ボトルネックの特定
- 統計情報の整形表示

✅ **実務で使えるレベル**
- 小〜中規模なプロジェクト
- デコレーターで手軽に計測
- 結果がすぐ見える

⚠️ **できないこと**
- 呼び出し階層の可視化（フレームグラフは実装済みだが簡易版）
- 統計的プロファイリング（サンプリングベース）
- メモリプロファイリングの高度な機能

---

## 🎯 まとめ

**プロファイラーは「パフォーマンス改善の羅針」です。**

1. どこが遅いか分かる
2. そこを改善する
3. 改善の効果を測る
4. 次のボトルネックを見つけて改善する

これを繰り返すことで、コードがどんどん速くなります。

---

**作成者**: Claude (Sonnet 4.5)
**最終更新**: 2026-01-18 02:15
**品質レベル**: 65点（実用的）
